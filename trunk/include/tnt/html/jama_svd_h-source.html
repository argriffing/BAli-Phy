<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>jama_svd.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.5 on Wed Aug 28 02:59:45 2002 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; </center>
<hr><h1>jama_svd.h</h1><a href="jama_svd_h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="preprocessor">#ifndef JAMA_SVD_H</font>
00002 <font class="preprocessor"></font><font class="preprocessor">#define JAMA_SVD_H</font>
00003 <font class="preprocessor"></font>
00004 
00005 <font class="preprocessor">#include "tnt_array1d.h"</font>
00006 <font class="preprocessor">#include "tnt_array1d_utils.h"</font>
00007 <font class="preprocessor">#include "tnt_array2d.h"</font>
00008 <font class="preprocessor">#include "tnt_array2d_utils.h"</font>
00009 <font class="preprocessor">#include "tnt_math_utils.h"</font>
00010 
00011 
00012 <font class="keyword">using</font> <font class="keyword">namespace </font>TNT;
00013 
00014 <font class="keyword">namespace </font>JAMA
00015 {
00033 template &lt;class Real&gt;
<a name="l00034"></a><a class="code" href="class_JAMA__SVD.html">00034</a> <font class="keyword">class </font>SVD 
00035 {
00036 
00037 
00038         Array2D&lt;Real&gt; U, V;
00039         Array1D&lt;Real&gt; s;
00040         <font class="keywordtype">int</font> m, n;
00041 
00042   <font class="keyword">public</font>:
00043 
00044 
<a name="l00045"></a><a class="code" href="class_JAMA__SVD.html#a0">00045</a>    <a class="code" href="class_JAMA__SVD.html#a0">SVD</a> (<font class="keyword">const</font> Array2D&lt;Real&gt; &amp;Arg)<font class="keyword"> </font>{
00046 
00047 
00048       m = Arg.dim1();
00049       n = Arg.dim2();
00050       <font class="keywordtype">int</font> nu = min(m,n);
00051       s = Array1D&lt;Real&gt;(min(m+1,n)); 
00052       U = Array2D&lt;Real&gt;(m, nu);
00053       V = Array2D&lt;Real&gt;(n,n);
00054       Array1D&lt;Real&gt; e(n);
00055       Array1D&lt;Real&gt; work(m);
00056           Array2D&lt;Real&gt; A(Arg);
00057       <font class="keywordtype">int</font> wantu = 1;                                    <font class="comment">/* boolean */</font>
00058       <font class="keywordtype">int</font> wantv = 1;                                    <font class="comment">/* boolean */</font>
00059 
00060       <font class="comment">// Reduce A to bidiagonal form, storing the diagonal elements</font>
00061       <font class="comment">// in s and the super-diagonal elements in e.</font>
00062 
00063       <font class="keywordtype">int</font> nct = min(m-1,n);
00064       <font class="keywordtype">int</font> nrt = max(0,min(n-2,m));
00065       <font class="keywordflow">for</font> (<font class="keywordtype">int</font> k = 0; k &lt; max(nct,nrt); k++) {
00066          <font class="keywordflow">if</font> (k &lt; nct) {
00067 
00068             <font class="comment">// Compute the transformation for the k-th column and</font>
00069             <font class="comment">// place the k-th diagonal in s[k].</font>
00070             <font class="comment">// Compute 2-norm of k-th column without under/overflow.</font>
00071             s[k] = 0;
00072             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = k; i &lt; m; i++) {
00073                s[k] = hypot(s[k],A[i][k]);
00074             }
00075             <font class="keywordflow">if</font> (s[k] != 0.0) {
00076                <font class="keywordflow">if</font> (A[k][k] &lt; 0.0) {
00077                   s[k] = -s[k];
00078                }
00079                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = k; i &lt; m; i++) {
00080                   A[i][k] /= s[k];
00081                }
00082                A[k][k] += 1.0;
00083             }
00084             s[k] = -s[k];
00085          }
00086          <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = k+1; j &lt; n; j++) {
00087             <font class="keywordflow">if</font> ((k &lt; nct) &amp;&amp; (s[k] != 0.0))  {
00088 
00089             <font class="comment">// Apply the transformation.</font>
00090 
00091                <font class="keywordtype">double</font> t = 0;
00092                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = k; i &lt; m; i++) {
00093                   t += A[i][k]*A[i][j];
00094                }
00095                t = -t/A[k][k];
00096                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = k; i &lt; m; i++) {
00097                   A[i][j] += t*A[i][k];
00098                }
00099             }
00100 
00101             <font class="comment">// Place the k-th row of A into e for the</font>
00102             <font class="comment">// subsequent calculation of the row transformation.</font>
00103 
00104             e[j] = A[k][j];
00105          }
00106          <font class="keywordflow">if</font> (wantu &amp; (k &lt; nct)) {
00107 
00108             <font class="comment">// Place the transformation in U for subsequent back</font>
00109             <font class="comment">// multiplication.</font>
00110 
00111             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = k; i &lt; m; i++) {
00112                U[i][k] = A[i][k];
00113             }
00114          }
00115          <font class="keywordflow">if</font> (k &lt; nrt) {
00116 
00117             <font class="comment">// Compute the k-th row transformation and place the</font>
00118             <font class="comment">// k-th super-diagonal in e[k].</font>
00119             <font class="comment">// Compute 2-norm without under/overflow.</font>
00120             e[k] = 0;
00121             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = k+1; i &lt; n; i++) {
00122                e[k] = hypot(e[k],e[i]);
00123             }
00124             <font class="keywordflow">if</font> (e[k] != 0.0) {
00125                <font class="keywordflow">if</font> (e[k+1] &lt; 0.0) {
00126                   e[k] = -e[k];
00127                }
00128                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = k+1; i &lt; n; i++) {
00129                   e[i] /= e[k];
00130                }
00131                e[k+1] += 1.0;
00132             }
00133             e[k] = -e[k];
00134             <font class="keywordflow">if</font> ((k+1 &lt; m) &amp; (e[k] != 0.0)) {
00135 
00136             <font class="comment">// Apply the transformation.</font>
00137 
00138                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = k+1; i &lt; m; i++) {
00139                   work[i] = 0.0;
00140                }
00141                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = k+1; j &lt; n; j++) {
00142                   <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = k+1; i &lt; m; i++) {
00143                      work[i] += e[j]*A[i][j];
00144                   }
00145                }
00146                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = k+1; j &lt; n; j++) {
00147                   <font class="keywordtype">double</font> t = -e[j]/e[k+1];
00148                   <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = k+1; i &lt; m; i++) {
00149                      A[i][j] += t*work[i];
00150                   }
00151                }
00152             }
00153             <font class="keywordflow">if</font> (wantv) {
00154 
00155             <font class="comment">// Place the transformation in V for subsequent</font>
00156             <font class="comment">// back multiplication.</font>
00157 
00158                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = k+1; i &lt; n; i++) {
00159                   V[i][k] = e[i];
00160                }
00161             }
00162          }
00163       }
00164 
00165       <font class="comment">// Set up the final bidiagonal matrix or order p.</font>
00166 
00167       <font class="keywordtype">int</font> p = min(n,m+1);
00168       <font class="keywordflow">if</font> (nct &lt; n) {
00169          s[nct] = A[nct][nct];
00170       }
00171       <font class="keywordflow">if</font> (m &lt; p) {
00172          s[p-1] = 0.0;
00173       }
00174       <font class="keywordflow">if</font> (nrt+1 &lt; p) {
00175          e[nrt] = A[nrt][p-1];
00176       }
00177       e[p-1] = 0.0;
00178 
00179       <font class="comment">// If required, generate U.</font>
00180 
00181       <font class="keywordflow">if</font> (wantu) {
00182          <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = nct; j &lt; nu; j++) {
00183             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt; m; i++) {
00184                U[i][j] = 0.0;
00185             }
00186             U[j][j] = 1.0;
00187          }
00188          <font class="keywordflow">for</font> (<font class="keywordtype">int</font> k = nct-1; k &gt;= 0; k--) {
00189             <font class="keywordflow">if</font> (s[k] != 0.0) {
00190                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = k+1; j &lt; nu; j++) {
00191                   <font class="keywordtype">double</font> t = 0;
00192                   <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = k; i &lt; m; i++) {
00193                      t += U[i][k]*U[i][j];
00194                   }
00195                   t = -t/U[k][k];
00196                   <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = k; i &lt; m; i++) {
00197                      U[i][j] += t*U[i][k];
00198                   }
00199                }
00200                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = k; i &lt; m; i++ ) {
00201                   U[i][k] = -U[i][k];
00202                }
00203                U[k][k] = 1.0 + U[k][k];
00204                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt; k-1; i++) {
00205                   U[i][k] = 0.0;
00206                }
00207             } <font class="keywordflow">else</font> {
00208                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt; m; i++) {
00209                   U[i][k] = 0.0;
00210                }
00211                U[k][k] = 1.0;
00212             }
00213          }
00214       }
00215 
00216       <font class="comment">// If required, generate V.</font>
00217 
00218       <font class="keywordflow">if</font> (wantv) {
00219          <font class="keywordflow">for</font> (<font class="keywordtype">int</font> k = n-1; k &gt;= 0; k--) {
00220             <font class="keywordflow">if</font> ((k &lt; nrt) &amp; (e[k] != 0.0)) {
00221                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = k+1; j &lt; nu; j++) {
00222                   <font class="keywordtype">double</font> t = 0;
00223                   <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = k+1; i &lt; n; i++) {
00224                      t += V[i][k]*V[i][j];
00225                   }
00226                   t = -t/V[k+1][k];
00227                   <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = k+1; i &lt; n; i++) {
00228                      V[i][j] += t*V[i][k];
00229                   }
00230                }
00231             }
00232             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt; n; i++) {
00233                V[i][k] = 0.0;
00234             }
00235             V[k][k] = 1.0;
00236          }
00237       }
00238 
00239       <font class="comment">// Main iteration loop for the singular values.</font>
00240 
00241       <font class="keywordtype">int</font> pp = p-1;
00242       <font class="keywordtype">int</font> iter = 0;
00243       <font class="keywordtype">double</font> eps = pow(2.0,-52.0);
00244       <font class="keywordflow">while</font> (p &gt; 0) {
00245          <font class="keywordtype">int</font> k=0;
00246                  <font class="keywordtype">int</font> kase=0;
00247 
00248          <font class="comment">// Here is where a test for too many iterations would go.</font>
00249 
00250          <font class="comment">// This section of the program inspects for</font>
00251          <font class="comment">// negligible elements in the s and e arrays.  On</font>
00252          <font class="comment">// completion the variables kase and k are set as follows.</font>
00253 
00254          <font class="comment">// kase = 1     if s(p) and e[k-1] are negligible and k&lt;p</font>
00255          <font class="comment">// kase = 2     if s(k) is negligible and k&lt;p</font>
00256          <font class="comment">// kase = 3     if e[k-1] is negligible, k&lt;p, and</font>
00257          <font class="comment">//              s(k), ..., s(p) are not negligible (qr step).</font>
00258          <font class="comment">// kase = 4     if e(p-1) is negligible (convergence).</font>
00259 
00260          <font class="keywordflow">for</font> (k = p-2; k &gt;= -1; k--) {
00261             <font class="keywordflow">if</font> (k == -1) {
00262                <font class="keywordflow">break</font>;
00263             }
00264             <font class="keywordflow">if</font> (abs(e[k]) &lt;= eps*(abs(s[k]) + abs(s[k+1]))) {
00265                e[k] = 0.0;
00266                <font class="keywordflow">break</font>;
00267             }
00268          }
00269          <font class="keywordflow">if</font> (k == p-2) {
00270             kase = 4;
00271          } <font class="keywordflow">else</font> {
00272             <font class="keywordtype">int</font> ks;
00273             <font class="keywordflow">for</font> (ks = p-1; ks &gt;= k; ks--) {
00274                <font class="keywordflow">if</font> (ks == k) {
00275                   <font class="keywordflow">break</font>;
00276                }
00277                <font class="keywordtype">double</font> t = (ks != p ? abs(e[ks]) : 0.) + 
00278                           (ks != k+1 ? abs(e[ks-1]) : 0.);
00279                <font class="keywordflow">if</font> (abs(s[ks]) &lt;= eps*t)  {
00280                   s[ks] = 0.0;
00281                   <font class="keywordflow">break</font>;
00282                }
00283             }
00284             <font class="keywordflow">if</font> (ks == k) {
00285                kase = 3;
00286             } <font class="keywordflow">else</font> <font class="keywordflow">if</font> (ks == p-1) {
00287                kase = 1;
00288             } <font class="keywordflow">else</font> {
00289                kase = 2;
00290                k = ks;
00291             }
00292          }
00293          k++;
00294 
00295          <font class="comment">// Perform the task indicated by kase.</font>
00296 
00297          <font class="keywordflow">switch</font> (kase) {
00298 
00299             <font class="comment">// Deflate negligible s(p).</font>
00300 
00301             <font class="keywordflow">case</font> 1: {
00302                <font class="keywordtype">double</font> f = e[p-2];
00303                e[p-2] = 0.0;
00304                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = p-2; j &gt;= k; j--) {
00305                   <font class="keywordtype">double</font> t = hypot(s[j],f);
00306                   <font class="keywordtype">double</font> cs = s[j]/t;
00307                   <font class="keywordtype">double</font> sn = f/t;
00308                   s[j] = t;
00309                   <font class="keywordflow">if</font> (j != k) {
00310                      f = -sn*e[j-1];
00311                      e[j-1] = cs*e[j-1];
00312                   }
00313                   <font class="keywordflow">if</font> (wantv) {
00314                      <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt; n; i++) {
00315                         t = cs*V[i][j] + sn*V[i][p-1];
00316                         V[i][p-1] = -sn*V[i][j] + cs*V[i][p-1];
00317                         V[i][j] = t;
00318                      }
00319                   }
00320                }
00321             }
00322             <font class="keywordflow">break</font>;
00323 
00324             <font class="comment">// Split at negligible s(k).</font>
00325 
00326             <font class="keywordflow">case</font> 2: {
00327                <font class="keywordtype">double</font> f = e[k-1];
00328                e[k-1] = 0.0;
00329                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = k; j &lt; p; j++) {
00330                   <font class="keywordtype">double</font> t = hypot(s[j],f);
00331                   <font class="keywordtype">double</font> cs = s[j]/t;
00332                   <font class="keywordtype">double</font> sn = f/t;
00333                   s[j] = t;
00334                   f = -sn*e[j];
00335                   e[j] = cs*e[j];
00336                   <font class="keywordflow">if</font> (wantu) {
00337                      <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt; m; i++) {
00338                         t = cs*U[i][j] + sn*U[i][k-1];
00339                         U[i][k-1] = -sn*U[i][j] + cs*U[i][k-1];
00340                         U[i][j] = t;
00341                      }
00342                   }
00343                }
00344             }
00345             <font class="keywordflow">break</font>;
00346 
00347             <font class="comment">// Perform one qr step.</font>
00348 
00349             <font class="keywordflow">case</font> 3: {
00350 
00351                <font class="comment">// Calculate the shift.</font>
00352    
00353                <font class="keywordtype">double</font> scale = max(max(max(max(
00354                        abs(s[p-1]),abs(s[p-2])),abs(e[p-2])), 
00355                        abs(s[k])),abs(e[k]));
00356                <font class="keywordtype">double</font> sp = s[p-1]/scale;
00357                <font class="keywordtype">double</font> spm1 = s[p-2]/scale;
00358                <font class="keywordtype">double</font> epm1 = e[p-2]/scale;
00359                <font class="keywordtype">double</font> sk = s[k]/scale;
00360                <font class="keywordtype">double</font> ek = e[k]/scale;
00361                <font class="keywordtype">double</font> b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;
00362                <font class="keywordtype">double</font> c = (sp*epm1)*(sp*epm1);
00363                <font class="keywordtype">double</font> shift = 0.0;
00364                <font class="keywordflow">if</font> ((b != 0.0) | (c != 0.0)) {
00365                   shift = sqrt(b*b + c);
00366                   <font class="keywordflow">if</font> (b &lt; 0.0) {
00367                      shift = -shift;
00368                   }
00369                   shift = c/(b + shift);
00370                }
00371                <font class="keywordtype">double</font> f = (sk + sp)*(sk - sp) + shift;
00372                <font class="keywordtype">double</font> g = sk*ek;
00373    
00374                <font class="comment">// Chase zeros.</font>
00375    
00376                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = k; j &lt; p-1; j++) {
00377                   <font class="keywordtype">double</font> t = hypot(f,g);
00378                   <font class="keywordtype">double</font> cs = f/t;
00379                   <font class="keywordtype">double</font> sn = g/t;
00380                   <font class="keywordflow">if</font> (j != k) {
00381                      e[j-1] = t;
00382                   }
00383                   f = cs*s[j] + sn*e[j];
00384                   e[j] = cs*e[j] - sn*s[j];
00385                   g = sn*s[j+1];
00386                   s[j+1] = cs*s[j+1];
00387                   <font class="keywordflow">if</font> (wantv) {
00388                      <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt; n; i++) {
00389                         t = cs*V[i][j] + sn*V[i][j+1];
00390                         V[i][j+1] = -sn*V[i][j] + cs*V[i][j+1];
00391                         V[i][j] = t;
00392                      }
00393                   }
00394                   t = hypot(f,g);
00395                   cs = f/t;
00396                   sn = g/t;
00397                   s[j] = t;
00398                   f = cs*e[j] + sn*s[j+1];
00399                   s[j+1] = -sn*e[j] + cs*s[j+1];
00400                   g = sn*e[j+1];
00401                   e[j+1] = cs*e[j+1];
00402                   <font class="keywordflow">if</font> (wantu &amp;&amp; (j &lt; m-1)) {
00403                      <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt; m; i++) {
00404                         t = cs*U[i][j] + sn*U[i][j+1];
00405                         U[i][j+1] = -sn*U[i][j] + cs*U[i][j+1];
00406                         U[i][j] = t;
00407                      }
00408                   }
00409                }
00410                e[p-2] = f;
00411                iter = iter + 1;
00412             }
00413             <font class="keywordflow">break</font>;
00414 
00415             <font class="comment">// Convergence.</font>
00416 
00417             <font class="keywordflow">case</font> 4: {
00418 
00419                <font class="comment">// Make the singular values positive.</font>
00420    
00421                <font class="keywordflow">if</font> (s[k] &lt;= 0.0) {
00422                   s[k] = (s[k] &lt; 0.0 ? -s[k] : 0.0);
00423                   <font class="keywordflow">if</font> (wantv) {
00424                      <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt;= pp; i++) {
00425                         V[i][k] = -V[i][k];
00426                      }
00427                   }
00428                }
00429    
00430                <font class="comment">// Order the singular values.</font>
00431    
00432                <font class="keywordflow">while</font> (k &lt; pp) {
00433                   <font class="keywordflow">if</font> (s[k] &gt;= s[k+1]) {
00434                      <font class="keywordflow">break</font>;
00435                   }
00436                   <font class="keywordtype">double</font> t = s[k];
00437                   s[k] = s[k+1];
00438                   s[k+1] = t;
00439                   <font class="keywordflow">if</font> (wantv &amp;&amp; (k &lt; n-1)) {
00440                      <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt; n; i++) {
00441                         t = V[i][k+1]; V[i][k+1] = V[i][k]; V[i][k] = t;
00442                      }
00443                   }
00444                   <font class="keywordflow">if</font> (wantu &amp;&amp; (k &lt; m-1)) {
00445                      <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt; m; i++) {
00446                         t = U[i][k+1]; U[i][k+1] = U[i][k]; U[i][k] = t;
00447                      }
00448                   }
00449                   k++;
00450                }
00451                iter = 0;
00452                p--;
00453             }
00454             <font class="keywordflow">break</font>;
00455          }
00456       }
00457    }
00458 
00459 
<a name="l00460"></a><a class="code" href="class_JAMA__SVD.html#a1">00460</a>    <font class="keywordtype">void</font> <a class="code" href="class_JAMA__SVD.html#a1">getU</a> (Array2D&lt;Real&gt; &amp;A)<font class="keyword"> </font>
00461 <font class="keyword">   </font>{
00462           <font class="keywordtype">int</font> minm = min(m+1,n);
00463 
00464           A = Array2D&lt;Real&gt;(m, minm);
00465 
00466           <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i=0; i&lt;m; i++)
00467                 <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j=0; j&lt;minm; j++)
00468                         A[i][j] = U[i][j];
00469         
00470    }
00471 
00472    <font class="comment">/* Return the right singular vectors */</font>
00473 
<a name="l00474"></a><a class="code" href="class_JAMA__SVD.html#a2">00474</a>    <font class="keywordtype">void</font> <a class="code" href="class_JAMA__SVD.html#a2">getV</a> (Array2D&lt;Real&gt; &amp;A)<font class="keyword"> </font>
00475 <font class="keyword">   </font>{
00476           A = V;
00477    }
00478 
00480 
<a name="l00481"></a><a class="code" href="class_JAMA__SVD.html#a3">00481</a>    <font class="keywordtype">void</font> <a class="code" href="class_JAMA__SVD.html#a3">getSingularValues</a> (Array1D&lt;Real&gt; &amp;x)<font class="keyword"> </font>
00482 <font class="keyword">   </font>{
00483       x = s;
00484    }
00485 
00489 
<a name="l00490"></a><a class="code" href="class_JAMA__SVD.html#a4">00490</a>    <font class="keywordtype">void</font> <a class="code" href="class_JAMA__SVD.html#a4">getS</a> (Array2D&lt;Real&gt; &amp;A)<font class="keyword"> </font>{
00491           A = Array2D&lt;Real&gt;(n,n);
00492       <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt; n; i++) {
00493          <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = 0; j &lt; n; j++) {
00494             A[i][j] = 0.0;
00495          }
00496          A[i][i] = s[i];
00497       }
00498    }
00499 
00501 
<a name="l00502"></a><a class="code" href="class_JAMA__SVD.html#a5">00502</a>    <font class="keywordtype">double</font> <a class="code" href="class_JAMA__SVD.html#a5">norm2</a> ()<font class="keyword"> </font>{
00503       <font class="keywordflow">return</font> s[0];
00504    }
00505 
00507 
<a name="l00508"></a><a class="code" href="class_JAMA__SVD.html#a6">00508</a>    <font class="keywordtype">double</font> <a class="code" href="class_JAMA__SVD.html#a6">cond</a> ()<font class="keyword"> </font>{
00509       <font class="keywordflow">return</font> s[0]/s[min(m,n)-1];
00510    }
00511 
00515 
<a name="l00516"></a><a class="code" href="class_JAMA__SVD.html#a7">00516</a>    <font class="keywordtype">int</font> <a class="code" href="class_JAMA__SVD.html#a7">rank</a> ()<font class="keyword"> </font>
00517 <font class="keyword">   </font>{
00518       <font class="keywordtype">double</font> eps = pow(2.0,-52.0);
00519       <font class="keywordtype">double</font> tol = max(m,n)*s[0]*eps;
00520       <font class="keywordtype">int</font> r = 0;
00521       <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt; s.dim(); i++) {
00522          <font class="keywordflow">if</font> (s[i] &gt; tol) {
00523             r++;
00524          }
00525       }
00526       <font class="keywordflow">return</font> r;
00527    }
00528 };
00529 
00530 }
00531 <font class="preprocessor">#endif</font>
00532 <font class="preprocessor"></font><font class="comment">// JAMA_SVD_H</font>
</div></pre><hr><address><small>Generated at Wed Aug 28 02:59:45 2002 for TemplateNumericalToolkit(TNT) by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.5 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
