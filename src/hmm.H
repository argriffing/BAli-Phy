#ifndef HMM_H
#define HMM_H

#include "mytypes.H"
#include "logsum.H"

using std::valarray;

// Can I make Q into a general function, backed by a matrix in some cases?

/// A Hidden Markov Model - represented by the transition matrix and accessory functions

class HMM {
  /// Is each state part of the silent network?
  vector<int> silent_network_;

  /// Order list of states that are part of silent networks
  vector<int> silent_network_states;

  /// An ordered list of states, for DP
  vector<int> order_;

  double HMM::generalize_P_one(vector<int>::const_iterator,int) const;

  void find_and_index_silent_network_states();

public:
  /// The 'temperature' - e.g. scale log(P) => log(P)/T
  double T;

  /// The transition matrix for the HMM
  eMatrix Q;

  /// The 'generalized' transition matrix - silent loops removed
  eMatrix GQ;

  bool connected_Q(int S1,int S2) const {return Q(S1,S2) != 0.0;}

  bool connected(int S1,int S2) const {return GQ(S1,S2) != 0.0;}

  /// Probabilities of starting in each state
  vector<efloat_t> start_P;

  /// bitmasks of whether states emit features in each sequence
  vector<int> state_emit;

  /// Is state S a silent state?
  bool silent(int S) const {return not state_emit[S];}

  /// Is state S part of a loop of silent states?  FIXME: s/network/cycle/...
  bool silent_network(int S) const;

  /// What is the n-th state, in the correct order for DP?
  int order(int i) const {assert(i <= nstates()+1);  return order_[i];}

  /// Number of states, minus the end state
  int nstates() const {return state_emit.size()-1;}

  /// The index of the end state
  int endstate() const {return nstates();}

  /// Convert a path to a generalized path
  vector<int> generalize(const vector<int>& path) const;

  /// Randomly sample a path from a generalized path g_path
  vector<int> ungeneralize(const vector<int>& g_path) const;

  /// Calculates the (log) probability that path would be generated by its generalized dual
  double generalize_P(const vector<int>& path) const;

  /// Calculates the (log) product of each move, according to the generalized HMM
  double path_Q_path(const vector<int>& path) const;

  /// Calculates the (log) product of each move, according to the generalized HMM
  double path_GQ_path(const vector<int>& g_path) const;

  /// Construct an HMM from the emission characteristics of the states, the start probabilities, and the transition matrix
  HMM(const vector<int>&,const vector<efloat_t>&,const Matrix&,double);

  virtual ~HMM() {}
};

#endif
