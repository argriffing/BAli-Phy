#ifndef TREE_DIST_H
#define TREE_DIST_H

#include <vector>
#include <list>
#include <valarray>

#include <string>
#include <iostream>

#include <map>

#include "tree.H"
#include "sequencetree.H"
#include "util.H"

SequenceTree standardized(const std::string& t,const std::vector<std::string>& remove);
SequenceTree standardized(SequenceTree T,const std::vector<std::string>& remove);

/// Return a bitmask of LEAF taxa (instead of all taxa) generated by branch b
std::valarray<bool> branch_partition(const Tree& T,int b);

/// Are two bitmasks equal to each other?
bool equal(const std::valarray<bool>& v1,const std::valarray<bool>& v2);

/// Represents a division of a subset of leaf taxa into 2 groups
struct Partition {
  std::vector<std::string> names;

  std::valarray<bool> split;
  std::valarray<bool> mask;

  int size() const {return split.size();}

  bool implied_by(const std::valarray<bool>& bm) const;

  Partition(const std::vector<std::string>& n,const std::valarray<bool>& v) 
    :names(n),split(v),mask(true,v.size()) 
  {
    assert(n.size() == v.size());
  }
 
  Partition(const std::vector<std::string>& n,const std::valarray<bool>& v1,const std::valarray<bool>& v2) 
    :names(n),split(v1),mask(v2)
  {
    split &= mask;
    assert(n.size() == v1.size());
    assert(v1.size() == v2.size());
  }
};

bool operator==(const Partition& p1, const Partition& p2);

/// Does any branch in T imply the partition p?
bool contains_partition(const SequenceTree& T,const Partition& p);

/// Output the partition P to stream o
std::ostream& operator<<(std::ostream& o, const Partition& P);



class tree_sample {
  mutable std::map<std::string,int,lstr> index;

public:
  struct topology_record {
    // the topology string
    std::string topology;

    // a tree structure for this topology
    SequenceTree T;

    // branch length means
    std::vector<double> mean;

    // branch length variances
    std::vector<double> var;

    // how many times did we see this topology
    int count;

    topology_record(const SequenceTree&,const std::string&);
  };

  // the trees in the sample
  std::list<std::string> trees;

  // mapping from index in the sample to topology record
  std::vector<int> which_topology;

  std::vector<int> order;

  // the list of topologies, and associated info
  std::vector<topology_record> topologies;

  int get_index(const std::string& t) const;

  int size() const {return trees.size();}

  std::valarray<bool> supports_partition(const Partition& P) const;

  std::valarray<bool> supports_topology(const std::string& t) const;

  tree_sample(std::istream&,const std::vector<std::string>& remove,int skip=0,int max=-1);
};

SequenceTree standardized(const std::string& t);
SequenceTree standardized(const std::string& t,const std::vector<std::string>& remove);
SequenceTree standardized(SequenceTree T);
SequenceTree standardized(SequenceTree T,const std::vector<std::string>& remove);

double branch_distance(const SequenceTree& T1, const SequenceTree& T2);
double topology_distance(const SequenceTree& T1, const SequenceTree& T2);

#endif
