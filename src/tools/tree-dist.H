#ifndef TREE_DIST_H
#define TREE_DIST_H

#include <vector>
#include <list>
#include <valarray>

#include <string>
#include <iostream>

#include <map>

#include "tree.H"
#include "sequencetree.H"
#include "util.H"

SequenceTree standardized(const std::string& t);
SequenceTree standardized(const std::string& t,const std::vector<std::string>& remove);

void standardize(SequenceTree& T);
void standardize(SequenceTree& T,const std::vector<std::string>& remove);

/// Return a bitmask of LEAF taxa (instead of all taxa) generated by branch b
std::valarray<bool> branch_partition(const Tree& T,int b);

/// Represents a division of a subset of leaf taxa into 2 groups
struct Partition {
  /// the names of all taxa 
  std::vector<std::string> names;

  /// the taxa in the first group
  std::valarray<bool> group1;

  /// the taxa in the second group
  std::valarray<bool> group2;

  /// the total number of taxa
  int size() const {return group1.size();}

  /// Create a partition of all taxa (g=0->g1,g=1->g2)
  Partition(const std::valarray<bool>& g);

  /// Create a partition of all taxa (g=0->g1,g=1->g2)
  Partition(const std::vector<std::string>& n,const std::valarray<bool>& g); 
 
  /// Create a partition of taxa present in @mask (g=0->g1,g=1->g2) 
  Partition(const std::valarray<bool>& g,const std::valarray<bool>& mask); 

  /// Create a partition of taxa present in @mask (g=0->g1,g=1->g2) 
  Partition(const std::vector<std::string>& n,const std::valarray<bool>& g,const std::valarray<bool>& mask);
};

Partition partition_from_names(const std::vector<std::string>&,const std::vector<std::string>&);

/// are both partitions the same?
bool operator==(const Partition& p1, const Partition& p2);

/// are both partitions consistent with each other?
bool consistent(const Partition& p1, const Partition& p2);

/// does partition @p1 imply partition @p2?
bool implies(const Partition& p1, const Partition& p2);

/// Does any branch in @T imply the partition @p?
bool implies(const SequenceTree& T,const Partition& p);

/// Does any branch in @T imply the partition @p?
bool implies(const SequenceTree& T,const std::vector<Partition>&);

int which_partition(const SequenceTree& T, const Partition& p);

/// Output the partition P to stream o (requires 'names' to be set)
std::ostream& operator<<(std::ostream& o, const Partition& P);


/// A class for loading tree distributions - somewhat biased towards tree-dist-compare
class tree_sample {
  mutable std::map<std::string,int,lstr> index;

public:

  /// The information we store about each topology
  struct topology_record {
    // the topology string
    std::string topology;

    // a tree structure for this topology
    SequenceTree T;

    // branch length means
    std::vector<double> mean;

    // branch length variances
    std::vector<double> var;

    // how many times did we see this topology
    int count;

    topology_record(const SequenceTree&,const std::string&);
  };

  // the trees in the sample
  std::list<std::string> trees;

  // mapping from index in the sample to topology record
  std::vector<int> which_topology;

  std::vector<int> order;

  // the list of topologies, and associated info
  std::vector<topology_record> topologies;

  int get_index(const std::string& t) const;

  int size() const {return trees.size();}

  std::valarray<bool> supports_topology(const std::string& t) const;

  std::valarray<bool> supports_partition(const Partition& P) const;

  std::valarray<bool> supports_partitions(const std::vector<Partition>&) const;

  double PP(const Partition& P) const;
  double PP(const std::vector<Partition>&) const;

  tree_sample(std::istream&,const std::vector<std::string>& remove,int skip=0,int max=-1);
};

SequenceTree standardized(const std::string& t);
SequenceTree standardized(const std::string& t,const std::vector<std::string>& remove);
SequenceTree standardized(SequenceTree T);
SequenceTree standardized(SequenceTree T,const std::vector<std::string>& remove);

double branch_distance(const SequenceTree& T1, const SequenceTree& T2);
double topology_distance(const SequenceTree& T1, const SequenceTree& T2);

std::vector<Partition> get_Ml_sub_partitions(const tree_sample& sample,double l,double r);
std::vector<Partition> get_Ml_partitions(const tree_sample& sample,double l);
std::vector<Partition> get_Ml_partitions(const tree_sample& sample,double l, 
					 const std::valarray<double>&);

SequenceTree get_mf_tree(const std::vector<std::string>& names,
			 const std::vector<Partition>& partitions);

#endif
