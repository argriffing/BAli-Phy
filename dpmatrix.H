#ifndef DPMATRIX_H
#define DPMATRIX_H

#include "mytypes.H"
#include "logsum.H"

using std::valarray;

// Can I make Q into a general function, backed by a matrix in some cases?


/// A Hidden Markov Model - represented by the transition matrix and accessory functions
class HMM {
  /// Is each state part of the silent network?
  vector<bool> silent_network_;

  /// An ordered list of states, for DP
  vector<int> order_;
public:
  /// The transition matrix for the HMM
  Matrix Q;

  /// The 'generalized' transition matrix - silent loops removed
  Matrix GQ;

  /// Probabilities of starting in each state
  vector<double> start_P;

  /// bitmasks of whether states emit features in each sequence
  vector<int> state_emit;

  /// Is state S a silent state?
  bool silent(int S) const {return not state_emit[S];}

  /// Is state S part of a loop of silent states?
  bool silent_network(int S) const;

  /// What is the n-th state, in the correct order for DP?
  int order(int n) const;

  /// Number of states, minus the end state
  int nstates() const {return state_emit.size()-1;}

  /// The index of the end state
  int endstate() const {return nstates();}

  /// Convert a path to a generalized path
  vector<int> generalize(const vector<int>& path);

  /// Randomly sample a path from a generalized path g_path
  vector<int> ungeneralize(const vector<int>& g_path);

  /// Calculates the (log) probability that path would be generated by its generalized dual
  double generalize_P(const vector<int>& path);

  /// Calculates the (log) probability that this path is sampled by the generalized HMM
  virtual double path_P(const vector<int>& g_path)=0;

  /// Calculates the (log) product of each move, according to the generalized HMM
  double path_Q_path(const vector<int>& g_path);

  /// Calculate the (log) substitution probability along the path
  virtual double path_Q_subst(const vector<int>& g_path)=0;

  /// Calculate the (log) substitution probability of this path
  virtual double path_Q(const vector<int>& g_path) {
    return path_Q_path(g_path) + this->path_Q_subst(g_path);
  }

  /// Check of the relative probabilities of path1 and path2 agree with lp1+ls1 and lp2+ls2
  double check(const vector<int>& path1,const vector<int>& path2,double lp1,double ls1,double lp2,double ls2);

  /// Construct an HMM from the emission characteristics of the states, the start probabilities, and the transition matrix
  HMM(const vector<int>&,const vector<double>&,const Matrix&);

  virtual ~HMM() {}
};


/// 1D Dynamic Programming Matrix
class DParray : public HMM, public vector< vector<double> > {
  /// Length of the DP array
  int length;
public:
  double path_Q_subst(const vector<int>& path) {return 0;}

  /// Does state S emit?
  bool di(int S) {bool e = false; if (state_emit[S]&(1<<0)) e=true;return e;}

  /// Return the size of the array
  unsigned size() const {return length;}

  double path_P(const vector<int>& path);

  /// compute FP for the whole array
  void forward();

  /// compute FP for a cell
  virtual void forward(int)=0;

  /// Sample a path from the HMM
  vector<int> sample_path();

  /// Compute the probability of all possible paths through theHMM
  double Pr_sum_all_paths();

  /// Construct an 1D DP matrix from a length, and an HMM
  DParray(int,const vector<int>&,const vector<double>&,const Matrix&);

  virtual ~DParray() {}
};


/// 1D Dynamic Programming Matrix - with constraints on which states are allowed at each position
class DParrayConstrained: public DParray {
  /// The list of allowed states for each position
  vector< vector<int> > allowed_states;
public:
  /// Access the states allowed at position j
  const vector<int>& states(int j) const {return allowed_states[j];}
  /// Access the states allowed at position j
  vector<int>& states(int j) {return allowed_states[j];}

  /// Compute the forward probabilities for the entire array
  void forward();

  /// Compute the forward probabilities for one cell
  void forward(int);

  /// Construct an 1D DP matrix from a length, and an HMM
  DParrayConstrained(int,const vector<int>&,const vector<double>&,const Matrix&);

  virtual ~DParrayConstrained() {}
};

/// 2D Dynamic Programming Matrix
class DPmatrix : public HMM, public vector<Matrix> {
  /// Size of first dimension: 0...L1 = 0...S1-1
  int S1;
  /// Size of second dimension: 0...L2 = 0...S2-1
  int S2;
public:
  /// Access size of dim 1
  int size1() const {return S1;}
  /// Access size of dim 2
  int size2() const {return S2;}

  /// Does state S emit in dimension 1?
  bool di(int S) {bool e = false; if (state_emit[S]&(1<<0)) e=true;return e;}
  /// Does state S emit in dimension 2?
  bool dj(int S) {bool e = false; if (state_emit[S]&(1<<1)) e=true;return e;}

  /// Compute the forward probabilities for a square
  virtual void forward(int,int,int,int);

  /// Compute the forward probabilities for a square
  virtual void forward(int,int)=0;

  /// compute FP for entire matrix, with some points on path pinned
  void forward(const vector<int>&,double);

  /// Sample a path from the HMM
  vector<int> sample_path();

  double path_P(const vector<int>& path);

  /// Auxiliary method for computing probability of sampling a path
  double path_check(const vector<int>& path);

  /// compute the probability of all possible paths through the HMM
  double Pr_sum_all_paths();

  /// Construct a 2D DP matrix from the dimensions, and an HMM
  DPmatrix::DPmatrix(int i1,
		     int i2,
		     const vector<int>& v1,
		     const vector<double>& v2,
		     const Matrix& M);
  virtual ~DPmatrix() {}
};


/// 2D Dynamic Programming Matrix for chains which only emit or don't emit
class DPmatrixNoEmit: public DPmatrix {
public:
  /// Compute the forward probabilities for a square
  virtual void forward(int,int,int,int);

  /// Compute the forward probabilities for a cell
  virtual void forward(int,int);

  double path_Q_subst(const vector<int>& path) {return 0;}

  DPmatrixNoEmit::DPmatrixNoEmit(int i1,
		     int i2,
		     const vector<int>& v1,
		     const vector<double>& v2,
		     const Matrix& M)
    :DPmatrix(i1,i2,v1,v2,M) 
  {}

  virtual ~DPmatrixNoEmit() {}
};

inline void DPmatrixNoEmit::forward(int i2,int j2) { 

  assert(i2<size1());
  assert(j2<size2());

  for(int S2=0;S2<nstates();S2++) {
    Matrix& FS2 = (*this)[S2];

    //--- Get (i1,j1) from (i2,j2) and S2
    int i1 = i2;
    if (di(S2)) i1--;

    int j1 = j2;
    if (dj(S2)) j1--;

    //--- Don't go off the boundary -----
    if (i1<0 or j1<0)
      continue;

    //--- Compute Arrival Probability ----
    FS2(i2,j2) = log_0;
    for(int S1=0;S1<nstates();S1++) {
      Matrix& FS1 = (*this)[S1];

      FS2(i2,j2) = logsum(FS2(i2,j2), FS1(i1,j1) + GQ(S1,S2));
    }
  }
} 


/// 2D Dynamic Programming Matrix for chains which emit different things
class DPmatrixEmit : public DPmatrix {
protected:
  /// Precomputed emission probabilies for +-
  valarray<double> s1_sub;
  /// Precomputed emission probabilies for -+
  valarray<double> s2_sub;

public:
  /// Probabilities of the different rates
  const vector<double>& distribution;
  /// Emission probabilities for first sequence
  const vector< vector< valarray<double> > >& dists1;
  /// Emission probabilities for second sequence
  const vector< vector< valarray<double> > >& dists2;
  /// Frequencies at the root node - and equilibrium frequencies
  const valarray<double>& frequency;
  /// The number of different rates
  int nrates() const {return dists1[0].size();}

  double path_Q_subst(const vector<int>& path);

  /// Emission probabilities for ++
  double emitMM(int i,int j);
  /// Emission probabilities for -+
  double emit_M(int i,int j);
  /// Emission probabilities for +-
  double emitM_(int i,int j);
  /// Emission probabilities for --
  double emit__(int i,int j);

  /// Construct a DP array from an HMM, emission probabilities, and substitution model
  DPmatrixEmit::DPmatrixEmit(const vector<int>&,
			     const vector<double>&,
			     const Matrix&,
			     const vector< double >&,
			     const vector< vector< valarray<double> > >&,
			     const vector< vector< valarray<double> > >&, 
			     const valarray<double>&);
  
  virtual ~DPmatrixEmit() {}
};

inline double sum(const valarray<double>& v) {
  return v.sum();
}

inline double DPmatrixEmit::emitMM(int i,int j) {
  double total=0;
  for(int r=0;r<nrates();r++) {
    //    total += distribution[r]*sum(dists1[i-1][r] * frequency * dists2[j-1][r]);   HANDCODED
    double temp=0;
    const valarray<double>& v1 = dists1[i-1][r];
    const valarray<double>& v2 = dists2[j-1][r];
    for(int l=0;l<v1.size();l++)
      temp += v1[l]*frequency[l]*v2[l];
    total += distribution[r]*temp;
  }

  return log(total);
}

inline double DPmatrixEmit::emitM_(int i,int j) {
  return s1_sub[i-1];
}

inline double DPmatrixEmit::emit_M(int i,int j) {
  return s2_sub[j-1];
}

inline double DPmatrixEmit::emit__(int i,int j) {
  return 0;
}

/// 2D Dynamic Programming matrix with no constraints on states at each cell
class DPmatrixSimple: public DPmatrixEmit {
public:
  inline void forward(int,int) __attribute__((always_inline));
  void forward(int i1,int j1,int i2,int j2);

  // compute FP for entire matrix, with some points on path pinned
  void forward(const vector<int>&,double);

  DPmatrixSimple(const vector<int> & v1,
		 const vector<double> & v2,
		 const Matrix& M,
		 const vector< double >& d0,
		 const vector< vector< valarray<double> > >& d1,
		 const vector< vector< valarray<double> > >& d2, 
		 const valarray<double>& f):
    DPmatrixEmit(v1,v2,M,d0,d1,d2,f)
  { }

  virtual ~DPmatrixSimple() {}
};

inline void DPmatrixSimple::forward(int i2,int j2) { 

  assert(i2<size1());
  assert(j2<size2());

  for(int S2=0;S2<nstates();S2++) {
    Matrix& FS2 = (*this)[S2];

    //--- Get (i1,j1) from (i2,j2) and S2
    int i1 = i2;
    if (di(S2)) i1--;

    int j1 = j2;
    if (dj(S2)) j1--;

    //--- Don't go off the boundary -----
    if (i1<0 or j1<0)
      continue;

    //--- Compute Arrival Probability ----
    FS2(i2,j2) = log_0;
    for(int S1=0;S1<nstates();S1++) {
      Matrix& FS1 = (*this)[S1];

      FS2(i2,j2) = logsum(FS2(i2,j2), FS1(i1,j1) + GQ(S1,S2));
    }

    //--- Include Emission Probability----
    double sub;
    if (i1 != i2 and j1 != j2)
      sub = emitMM(i2,j2);
    else if (i1 != i2)
      sub = emitM_(i2,j2);
    else if (j1 != j2)
      sub = emit_M(i2,j2);
    else          // silent state - nothing emitted
      sub = emit__(i2,j2);


    FS2(i2,j2) += sub;
  }
} 

/// Dynamic Programming matrix with constraints on the states
class DPmatrixHMM: public DPmatrixEmit {
  vector< vector<int> > allowed_states;
public:
  const vector<int>& states(int j) const {return allowed_states[j];}
  vector<int>& states(int j) {return allowed_states[j];}

  inline void forward(int,int) __attribute__((always_inline));

  void forward(int i1,int j1,int i2,int j2);

  // compute FP for entire matrix, with some points on path pinned
  void forward(const vector<int>&,double);

  DPmatrixHMM(const vector<int> & v1,
	      const vector<double> & v2,
	      const Matrix& M,
	      const vector< double >& d0,
	      const vector< vector< valarray<double> > >& d1,const vector< vector< valarray<double> > >& d2, 
	      const valarray<double>& f):
    DPmatrixEmit(v1,v2,M,d0,d1,d2,f), allowed_states(d2.size()+1)
  { }

  virtual ~DPmatrixHMM() {}
};

inline void DPmatrixHMM::forward(int i2,int j2) { 

  assert(i2<size1());
  assert(j2<size2());

  for(int i=0;i<states(j2).size();i++) {
    int S2 = states(j2)[i];
    Matrix& FS2 = (*this)[S2];

    //--- Get (i1,j1) from (i2,j2) and S2
    int i1 = i2;
    if (di(S2))
      i1--;

    int j1 = j2;
    if (dj(S2))
      j1--;

    //--- Don't go off the boundary -----
    if (i1<0 or j1<0)
      continue;

    //--- Compute Arrival Probability ----
    FS2(i2,j2) = log_0;
    for(int s=0;s<states(j1).size();s++) {
      int S1 = states(j1)[s];
      Matrix& FS1 = (*this)[S1];

      FS2(i2,j2) = logsum(FS2(i2,j2), FS1(i1,j1) + GQ(S1,S2));
    }

    //--- Include Emission Probability----
    double sub;
    if (i1 != i2 and j1 != j2)
      sub = emitMM(i2,j2);
    else if (i1 != i2)
      sub = emitM_(i2,j2);
    else if (j1 != j2)
      sub = emit_M(i2,j2);
    else          // silent state - nothing emitted
      sub = emit__(i2,j2);


    FS2(i2,j2) += sub;
  }
}

#endif
